<!-- Generated by SpecStory -->

# VOD再生アルゴリズムの改造提案 (2025-08-29 13:17Z)

_**User**_

再生アルゴリズムを改造したいです
VODが読まれた場合、ストリーミングモードでまずは再生をして後からバックグラウンドでダウンロードを開始、その後にダウンロードが完了したらストリーミングからシームレスにローカル再生に移行というアルゴリズムにしたいです

---

_**Assistant**_

ご要望のアルゴリズムは以下の流れになります：

1. VOD（動画）が指定されたら、まずストリーミング再生を開始
2. ストリーミング再生中にバックグラウンドでダウンロードを開始
3. ダウンロードが完了したら、ストリーミングからローカルファイル再生へシームレスに切り替え

この実装には、以下の主な要素が必要です：

- ストリーミング再生とローカル再生の両方をサポートするプレイヤー
- バックグラウンドでのダウンロード処理（スレッドや非同期処理）
- ダウンロード完了検知と再生ソースの切り替えロジック

まず、`gui.py`で再生処理の流れやプレイヤーの制御部分を確認し、どこにこのアルゴリズムを組み込むかを特定します。その後、必要に応じて`core.py`などのロジック層も修正します。

次に、`gui.py`の再生処理部分を確認します。 設計方針と現状の流れを整理します。

現状の流れ（`gui.py`）：
- 「Stream」ボタン → `on_stream()` → `_start_spout_stream(url)` → `Streamer`生成（ストリーミング再生）
- 「Start」ボタン → `on_start()` → `download_video()`（バックグラウンドでダウンロード）→ 完了後`on_download_complete()`でローカル再生

ご要望の流れ：
1. VODの場合、まずストリーミング再生（`Streamer`でURL再生）
2. ストリーミング再生中にバックグラウンドでダウンロード開始
3. ダウンロード完了後、ストリーミングからローカルファイル再生へシームレスに切り替え

このためには、
- `on_stream()`でVODの場合はストリーミング再生＋同時にダウンロード開始
- ダウンロード完了時に、現在ストリーミング再生中ならローカルファイルへ切り替え

次に、`on_stream`と`on_download_complete`のロジックを改造し、VOD時にこのアルゴリズムを実装します。  
（`Streamer`の切り替えも考慮）

修正案を適用します。 
```

```
VODの場合、ストリーミング再生しながらバックグラウンドでダウンロードを開始し、ダウンロード完了後はシームレスにローカル再生へ切り替えるアルゴリズムを`gui.py`に実装しました。

- 「Stream」ボタンでVODなら自動的にこの動作になります。
- ダウンロード完了時、再生位置もできるだけ引き継ぎます。

ご希望の動作をお試しください。追加の調整やご要望があればお知らせください。

---

_**User**_

https://www.youtube.com/watch?v=dQw4w9WgXcQ からストリーミングを開始します...
コーデック対応状況: AV1 supported (decoders: libdav1d, libaom-av1, av1, up to 2160p)
Cookieファイルとして'data\cookies.txt'を使用します。
yt-dlp: [youtube] Extracting URL: https://www.youtube.com/watch?v=dQw4w9WgXcQ
yt-dlp: [youtube] dQw4w9WgXcQ: Downloading webpage
yt-dlp: [youtube] dQw4w9WgXcQ: Downloading tv client config
yt-dlp: [youtube] dQw4w9WgXcQ: Downloading tv player API JSON
yt-dlp: [youtube] dQw4w9WgXcQ: Downloading tv simply player API JSON
選択されたフォーマット: 401, コーデック: av01.0.12M.08, 解像度: 3840x2160
ffmpegコマンド: ffmpeg -loglevel warning -rw_timeout 5000000 -fflags +genpts+discardcorrupt+igndts -avoid_negative_ts make_zero -protocol_whitelist file,crypto,data,concat,subfile,http,https,tcp,tls,pipe -probesize 32M -analyzeduration 10M -user_agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36" -headers "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-us,en;q=0.5

Sec-Fetch-Mode: navigate

" -i https://rr2---sn-uxjoxu-ioqes.googlevideo.com/videoplayback?expire=1756528434&ei=0iqyaNKVD73h29gP3JuMgAU&ip=125.12.162.44&id=o-AJaKDTRHXCFkrkmP8I4_RRCge6HO2L_-BMoOCXMth-Hf&itag=401&aitags=133%2C134%2C135%2C136%2C137%2C160%2C242%2C243%2C244%2C247%2C248%2C271%2C278%2C313%2C394%2C395%2C396%2C397%2C398%2C399%2C400%2C401&source=youtube&requiressl=yes&xpc=EgVo2aDSNQ%3D%3D&met=1756506834%2C&mh=7c&mm=31%2C26&mn=sn-uxjoxu-ioqes%2Csn-npoe7nez&ms=au%2Conr&mv=m&mvi=2&pl=17&rms=au%2Cau&initcwndbps=2651250&bui=AY1jyLNrcYgOzH9mP7TM1D0gXyqN-uqh9gMQmnfOdZwr7MSjZYitnp5JF3YUpM5-qQVoCq2seMe3I5qT&spc=l3OVKY3P8CL-85F-G3uxwGO8_AZpgIVt7qetNwEksavFm_05GWuRrD2RDr245ACYVl6LdA&vprv=1&svpuc=1&mime=video%2Fmp4&ns=VTt06rcIZZB4zE6_BqMeqt8Q&rqh=1&gir=yes&clen=238254945&dur=213.040&lmt=1749085188214713&mt=1756506307&fvip=3&keepalive=yes&lmw=1&fexp=51557447%2C51565115%2C51565681%2C51580970&c=TVHTML5&sefc=1&txp=4532534&n=kexb0rVCF2Ux4w&sparams=expire%2Cei%2Cip%2Cid%2Caitags%2Csource%2Crequiressl%2Cxpc%2Cbui%2Cspc%2Cvprv%2Csvpuc%2Cmime%2Cns%2Crqh%2Cgir%2Cclen%2Cdur%2Clmt&lsparams=met%2Cmh%2Cmm%2Cmn%2Cms%2Cmv%2Cmvi%2Cpl%2Crms%2Cinitcwndbps&lsig=APaTxxMwRQIhAIlofJZ68H3Ys1LoL3z7EvQL3PmWK5-RAqDo5mbVjLIOAiBAJH_TBdaTOC1Ir8X2-GsuxjffuWR3j9nQo4VgNLG2Mg%3D%3D&sig=AJfQdSswRQIgaAbP6-wtnyHSzaG5H1Fg2eIAktYqFqbfoKvmWHRP9IoCIQD7F2926spbBiuJ4UgLo9-G807gkTLz63qexxeTEJe9_w%3D%3D -err_detect ignore_err -ignore_unknown -max_muxing_queue_size 1024 -threads 0 -vf scale=2560:1440:flags=lanczos -r 25 -f rawvideo -pix_fmt bgr24 pipe:1
ytdlpSpoutSender で送信を開始しました。(2560x1440) @ 25fps
動画の長さを取得しました: 213 秒
VOD を検出しました。1回再生します。

このログのあと、普通にストリーミング再生されてダウンロードが開始されたログとか何も流れてない

---

_**Assistant**_

現状のログを見ると、ストリーミング再生は正常に始まっていますが、「バックグラウンドでダウンロードを開始します」や「バックグラウンドで動画をローカル保存しました」など、ダウンロード関連のログが一切出ていません。

考えられる原因：
- `self.streamer.is_vod` の判定が `on_stream` 実行直後はまだ反映されていない（`Streamer`の初期化が非同期で遅延するため、VOD判定前にスレッドが終了している）
- もしくは、`yt_dlp`やスレッドの例外でダウンロード処理が開始されていない

対策案：
- `check_and_start_download` の待機ループを長めにし、`self.streamer`が生成され`is_vod`がTrueになるまでしっかり待つ
- さらに、`_start_background_download`の中でログ出力を追加し、ダウンロード開始・完了・失敗の各タイミングで必ずログが出るようにする

これらを修正して、ダウンロード処理の確実な開始とログ出力を保証します。 
```

```
VOD判定の待機時間を最大5秒に延長し、バックグラウンドダウンロードの開始・進行・完了・失敗時に必ずログが出るよう修正しました。

これで、ダウンロード処理が確実に開始され、進行状況もログに表示されるはずです。再度ストリーミングをお試しください。ログに「バックグラウンドダウンロード処理を開始します...」や「BGダウンロード中」などが出るかご確認ください。

---

_**User**_

BGダウンロード中: [0;94m 30.4%[0m ([0;32m  12.28MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード中: [0;94m 60.8%[0m ([0;32m  16.99MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード中: [0;94m100.0%[0m ([0;32m  20.12MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード完了
バックグラウンドで動画をローカル保存しました: data\dQw4w9WgXcQ.mp4
ローカルファイルへシームレスに切り替えます...
一時ファイルを削除しました: data\dQw4w9WgXcQ.mp4
None からストリーミングを開始します...
エラー: ストリーミング開始エラー: stat: path should be string, bytes, os.PathLike or integer, not NoneType

こんなエラーがでました

---

_**Assistant**_

このエラーの原因は、  
「一時ファイルを削除しました: data\dQw4w9WgXcQ.mp4」  
の直後に「None からストリーミングを開始します...」となっており、  
`self.local_video_path` が `None` になっている状態で `_start_spout_stream` が呼ばれているためです。

考えられる理由：
- yt-dlpのダウンロード完了後、ファイル名が一時的に消されている（または他の処理で削除されている）
- もしくは、`final_filename` の値が正しくセットされていない、またはスコープ外になっている

対策：
- `self.local_video_path` の値が `None` でないか、ファイルが存在するかを確認してから `_start_spout_stream` を呼ぶ
- ファイルが存在しない場合はエラーログを出して切り替えを中止する

このガードを追加します。 
```

```
ローカルファイルへ切り替える際、`self.local_video_path` が `None` またはファイルが存在しない場合は切り替えを中止し、エラーログを出すよう修正しました。

これで「None からストリーミングを開始します...」のようなエラーは防げます。  
再度お試しください。もしファイルが消えてしまう場合は、そのタイミングや原因も追加で調査できますのでご連絡ください。

---

_**User**_

BGダウンロード中: [0;94m  3.8%[0m ([0;32m   2.39MiB/s[0m, ETA: [0;33m00:01[0m)
BGダウンロード中: [0;94m  7.6%[0m ([0;32m   3.50MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード中: [0;94m 15.2%[0m ([0;32m   4.70MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード中: [0;94m 30.4%[0m ([0;32m   7.19MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード中: [0;94m 60.8%[0m ([0;32m   9.37MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード中: [0;94m100.0%[0m ([0;32m  11.10MiB/s[0m, ETA: [0;33m00:00[0m)
BGダウンロード完了
バックグラウンドで動画をローカル保存しました: data\dQw4w9WgXcQ.mp4
ローカルファイルへシームレスに切り替えます...
一時ファイルを削除しました: data\dQw4w9WgXcQ.mp4
ローカルファイル切り替え失敗: ファイルが存在しません (None)

こんな感じでダウンロードが終わっても勝手に消されて再生できないのはなぜ

---

_**Assistant**_

原因は、`on_stop()` 内で  
「ローカルファイルを削除」  
の処理が必ず実行されているためです。

シームレス切り替え時（＝バックグラウンドダウンロード完了時）は、  
1. `on_background_download_complete` で `self.on_stop()` を呼ぶ  
2. その中でローカルファイル（`self.local_video_path`）が削除される  
3. その後、`self._start_spout_stream(self.local_video_path)` を呼んでもファイルが消えている

このロジックだと、**切り替え時にローカルファイルが必ず消されてしまう**ため、再生できません。

【解決策】
- `on_stop()` でローカルファイルを削除するのは「ユーザーが明示的にStopした場合」や「一時ファイルとして使い終わった場合」のみに限定し、
- シームレス切り替え時（自動切り替え時）は削除しないようにします。

具体的には、`on_stop()` に「一時ファイル削除フラグ」を追加し、  
シームレス切り替え時は削除しないように修正します。

修正を行います。 
```

```
修正しました。  
これでシームレス切り替え時（バックグラウンドダウンロード完了時）はローカルファイルが削除されず、正常にローカル再生へ移行できるようになります。

ユーザーが明示的に「Stop」した場合のみ一時ファイルが削除されます。  
再度お試しください。

---

_**User**_

切り替え時に一瞬No Signalにならないでほしいのと、再生位置をちゃんと保持してほしい

---

_**Assistant**_

ご要望の「切り替え時にNo Signalを出さず、再生位置も正確に保持する」には、  
1. 切り替え中はプレビューをクリアしない（No Signalにしない）  
2. ローカル再生開始後、確実に前の再生位置へシークする

このためには  
- `on_stop(delete_local_file=False)` でUIリセットやプレビュークリアをスキップできるようにし、  
- シームレス切り替え時はUIリセット・プレビュークリアを行わず、  
- ローカル再生開始後、`self.streamer.seek(current_time)` を必ず呼ぶ（`on_stream_start_success` で自動シーク）

この2点を実装します。  
（UIリセットやプレビュークリアの制御はフラグで切り替えます）

修正を行います。 

---

